const ShaderMat4 = {
    m4RotateX:[
        "mat4 m4RotateX (float degX){",
            "float cx = cos(degX);" ,
            "float sx = sin(degX);" ,
            "return mat4(",
                "1.0, 0.0, 0.0, 0.0,",
                "0.0, cx,  -sx, 0.0,",
                "0.0, sx,  cx,  0.0,",
                "0.0, 0.0, 0.0, 1.0",
            ");",
        "}"
    ],
    m4RotateY:[
        "mat4 m4RotateY (float degY){",
            "float cy = cos(degY);" ,
            "float sy = sin(degY);" ,
            "return mat4(",
                "cy,  0.0, sy,  0.0,",
                "0.0, 1.0, 0.0, 0.0,",
                "-sy, 0.0, cy,  0.0,",
                "0.0, 0.0, 0.0, 1.0 ",
            ");",
        "}"
    ],
    m4RotateZ:[
        "mat4 m4RotateZ (float degZ){",
            "float cz = cos(degZ);" ,
            "float sz = sin(degZ);" ,
            "return mat4(",
                "cz,  -sz, 0.0, 0.0,",
                "sz, cz,  0.0, 0.0,",
                "0.0, 0.0, 1.0, 0.0,",
                "0.0, 0.0, 0.0, 1.0 ",
            ");",
        "}"
    ],
    m4Rotate3D:[
        "mat4 m4Rotate3D (float degX,float degY,float degZ,int orderNum){",
            "float cx = cos(degX);" ,
            "float sx = sin(degX);" ,
            "mat4 rotx = mat4(",
                "1.0, 0.0, 0.0, 0.0,",
                "0.0, cx,  -sx, 0.0,",
                "0.0, sx,  cx,  0.0,",
                "0.0, 0.0, 0.0, 1.0",
            ");",
            "float cy = cos(degY);" ,
            "float sy = sin(degY);" ,
            "mat4 roty = mat4(",
                "cy,  0.0, sy,  0.0,",
                "0.0, 1.0, 0.0, 0.0,",
                "-sy, 0.0, cy,  0.0,",
                "0.0, 0.0, 0.0, 1.0 ",
            ");",
            "float cz = cos(degZ);" ,
            "float sz = sin(degZ);" ,
            "mat4 rotz = mat4(",
                "cz,  -sz, 0.0, 0.0,",
                "sz, cz,  0.0, 0.0,",
                "0.0, 0.0, 1.0, 0.0,",
                "0.0, 0.0, 0.0, 1.0 ",
            ");",

            "if(orderNum == 123){",
                "return rotx * roty * rotz;",
            "}",
            "if(orderNum == 132){",
                "return rotx * rotz * roty;",
            "}",
            "if(orderNum == 213){",
                "return roty * rotx * rotz;",
            "}",
            "if(orderNum == 231){",
                "return roty * rotz * rotx;",
            "}",
            "if(orderNum == 312){",
                "return rotz * rotx * roty;",
            "}",
            "if(orderNum == 321){",
                "return rotz * roty * rotx;",
            "}",
        "}"
    ],
    m4RotateAxis:[
        "mat4 m4RotateAxis (vec3 axis, float deg){",
            "float x = axis.x;","float y = axis.y;","float z = axis.z;",
            "float c = cos(deg);","float t = 1.0 - c;","float s = sin(deg);",
            "float tx = t*x;","float ty = t*y;",
            "return mat4(",
                "tx*x+c,   tx*y-s*z, tx*z+s*y, 0.0,",
                "tx*y+s*z, ty*y+c,   ty*z-s*x, 0.0,",
                "tx*z-s*y, ty*z+s*x, t*z*z+c,  0.0,",
                "0.0,      0.0,      0.0,      1.0 ",
            ");",
        "}"
    ],
    m4RotateFromVectors:[
        "mat4 m4RotateFromVectors (vec3 vFrom, vec3 vTo){",
            "float r = dot(vFrom,vTo)+1.0;",
            "vec4 q = vec4(0.0);",
            "if( r < 0.0){",
                "r = 0.0;",
                "if(abs(vFrom.x) > abs(vFrom.z)){",
                    "q.x = -vFrom.y;",
                    "q.y = vFrom.x;",
                    "q.z = 0.0;",
                "}else{",
                    "q.x = 0.0;",
                    "q.y = -vFrom.z;",
                    "q.z = vFrom.y;",
                "}",
                "q.w = r;",
            "}else{",
                "q = vec4(cross(vFrom,vTo),r);",
                // "q.x = vFrom.y * vTo.z - vFrom.z * vTo.y;",
                // "q.y = vFrom.z * vTo.x - vFrom.x * vTo.z;",
                // "q.z = vFrom.x * vTo.y - vFrom.y * vTo.x;",
                // "q.w = r;",
            "}",
            "q = normalize(q);",
            "float x2 = q.x*q.x;", "float y2 = q.y*q.y;","float z2 = q.z*q.z;","float xy = q.x*q.y;",
            "float xz = q.x*q.z;","float yz = q.y*q.z;","float xw = q.x*q.w;","float yw = q.y*q.w;",
            "float zw = q.z*q.w;",
            "return mat4(",
                "1.0-2.0*(y2+z2), 2.0*(xy+zw),     2.0*(xz-yw),     0.0,",
                "2.0*(xy-zw),     1.0-2.0*(x2+z2), 2.0*(yz+xw),     0.0,",
                "2.0*(xz+yw),     2.0*(yz-xw),     1.0-2.0*(x2-y2), 0.0,",
                "0.0,             0.0,             0.0,             1.0 ",
            ");",

            // "float x2 = q.x+q.x;", "float y2 = q.y+q.y;","float z2 = q.z+q.z;",
            // "float xx = q.x*x2;", "float xy = q.x*y2;","float xz = q.x*z2;",
            // "float yy = q.y*y2;","float yz = q.y*z2;", "float zz = q.z*z2;",
            // "float wx = q.w*x2;","float wy = q.w*y2;", "float wz = q.w*z2;",
            // "return mat4(",
            //     "1.0-yy-zz, xy+wz,     xz-wy,     0.0,",
            //     "xy-wz,     1.0-xx-zz, yz+wx,     0.0,",
            //     "xz+wy,     yz-wx,     1.0-xx-yy, 0.0,",
            //     "0.0,       0.0,       0.0,       1.0 ",
            // ");",
        "}"
    ],
    m4GetScale:[
        "mat4 m4GetScale (mat4 mat){",
            "float sx = length(vec3(mat[0][0],mat[0][1],mat[0][2]));" ,
            "float sy = length(vec3(mat[1][0],mat[1][1],mat[1][2]));" ,
            "float sz = length(vec3(mat[2][0],mat[2][1],mat[2][2]));" ,
            "return mat4(",
                "sx,  0.0, 0.0, 0.0,",
                "0.0, sy,  0.0, 0.0,",
                "0.0, 0.0, sz,  0.0,",
                "0.0, 0.0, 0.0, 1.0 ",
            ");",
        "}"
    ]
};

export default ShaderMat4;