const ShaderMat3 = {
    m3RotateX:[
        "mat3 m3RotateX (float degX){",
            "float cx = cos(degX);" ,
            "float sx = sin(degX);" ,
            "return mat3(",
                "1.0, 0.0, 0.0,",
                "0.0, cx,  -sx,",
                "0.0, sx,  cx  ",
            ");",
        "}"
    ],
    m3RotateY:[
        "mat3 m3RotateY (float degY){",
            "float cy = cos(degY);" ,
            "float sy = sin(degY);" ,
            "return mat3(",
                "cy,  0.0, sy, ",
                "0.0, 1.0, 0.0,",
                "-sy, 0.0, cy ",
            ");",
        "}"
    ],
    m3RotateZ:[
        "mat3 m3RotateZ (float degZ){",
            "float cz = cos(degZ);" ,
            "float sz = sin(degZ);" ,
            "return mat3(",
                "cz,  -sz, 0.0,",
                "sz, cz,  0.0, ",
                "0.0, 0.0, 1.0,",
                "0.0, 0.0, 0.0 ",
            ");",
        "}"
    ],
    m3Rotate3D:[
        "mat3 m3Rotate3D (float degX,float degY,float degZ,int orderNum){",
            "float cx = cos(degX);" ,
            "float sx = sin(degX);" ,
            "mat3 rotx = mat3(",
                "1.0, 0.0, 0.0,",
                "0.0, cx,  -sx,",
                "0.0, sx,  cx  ",
            ");",
            "float cy = cos(degY);" ,
            "float sy = sin(degY);" ,
            "mat3 roty = mat3(",
                "cy,  0.0, sy, ",
                "0.0, 1.0, 0.0,",
                "-sy, 0.0, cy  ",
            ");",
            "float cz = cos(degZ);" ,
            "float sz = sin(degZ);" ,
            "mat3 rotz = mat3(",
                "cz,  -sz, 0.0,",
                "sz,  cz,  0.0, ",
                "0.0, 0.0, 1.0 ",
            ");",

            "if(orderNum == 123){",
                "return rotx * roty * rotz;",
            "}",
            "if(orderNum == 132){",
                "return rotx * rotz * roty;",
            "}",
            "if(orderNum == 213){",
                "return roty * rotx * rotz;",
            "}",
            "if(orderNum == 231){",
                "return roty * rotz * rotx;",
            "}",
            "if(orderNum == 312){",
                "return rotz * rotx * roty;",
            "}",
            "if(orderNum == 321){",
                "return rotz * roty * rotx;",
            "}",
        "}"
    ],
    m3RotateAxis:[
        "mat3 m3RotateAxis (vec3 axis, float deg){",
            "float x = axis.x;","float y = axis.y;","float z = axis.z;",
            "float c = cos(deg);","float t = 1.0 - c;","float s = sin(deg);",
            "float tx = t*x;","float ty = t*y;",
            "return mat3(",
                "tx*x+c,   tx*y-s*z, tx*z+s*y,",
                "tx*y+s*z, ty*y+c,   ty*z-s*x,",
                "tx*z-s*y, ty*z+s*x, t*z*z+c  ",
            ");",
        "}"
    ],
    m3RotateFromVectors:[
        "mat3 m3RotateFromVectors (vec3 vFrom, vec3 vTo){",
            "float r = dot(vFrom,vTo)+1.0;",
            "vec4 q = vec4(0.0);",
            "if( r < 0.0){",
                "r = 0.0;",
                "if(abs(vFrom.x) > abs(vFrom.z)){",
                    "q.x = -vFrom.y;",
                    "q.y = vFrom.x;",
                    "q.z = 0.0;",
                "}else{",
                    "q.x = 0.0;",
                    "q.y = -vFrom.z;",
                    "q.z = vFrom.y;",
                "}",
                "q.w = r;",
            "}else{",
                "q = vec4(cross(vFrom,vTo),r);",
            "}",
            "q = normalize(q);",
            "float x2 = q.x*q.x;", "float y2 = q.y*q.y;","float z2 = q.z*q.z;","float xy = q.x*q.y;",
            "float xz = q.x*q.z;","float yz = q.y*q.z;","float xw = q.x*q.w;","float yw = q.y*q.w;",
            "float zw = q.z*q.w;",
            "return mat3(",
                "1.0-2.0*(y2+z2), 2.0*(xy+zw),     2.0*(xz-yw),   ",
                "2.0*(xy-zw),     1.0-2.0*(x2+z2), 2.0*(yz+xw),   ",
                "2.0*(xz+yw),     2.0*(yz-xw),     1.0-2.0*(x2-y2)",
            ");",
        "}"
    ],
    m3GetScale:[
        "mat3 m3GetScale (mat4 mat){",
            "float sx = length(vec3(mat[0][0],mat[0][1],mat[0][2]));" ,
            "float sy = length(vec3(mat[1][0],mat[1][1],mat[1][2]));" ,
            "float sz = length(vec3(mat[2][0],mat[2][1],mat[2][2]));" ,
            "return mat3(",
                "sx,  0.0, 0.0, ",
                "0.0, sy,  0.0, ",
                "0.0, 0.0, sz  ",
            ");",
        "}"
    ]
};

export default ShaderMat3;